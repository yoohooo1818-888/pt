<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
<title>å€’æ°´æ¸¸æˆ - è‡ªé€‚åº”ç‰ˆ</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; touch-action:none; -webkit-tap-highlight-color:transparent; user-select:none; overflow:hidden; }
html, body { width:100%; height:100%; background:#0a1628; }
#gameCanvas { display:block; width:100%; height:100%; }
.hint { 
  position:fixed; top:15%; left:50%; transform:translateX(-50%);
  background:rgba(0,0,0,0.7); color:#fff; padding:12px 30px; border-radius:25px;
  font-size:16px; pointer-events:none; z-index:100; white-space:nowrap;
  border:1px solid rgba(255,255,255,0.2);
}
.hint.error { color:#ff6b6b; border-color:#ff6b6b; animation:shake 0.5s; }
@keyframes shake { 0%,100%{transform:translateX(-50%) translateX(0);} 25%{transform:translateX(-50%) translateX(-10px);} 75%{transform:translateX(-50%) translateX(10px);} }
.cta { 
  position:fixed; bottom:5%; left:50%; transform:translateX(-50%);
  background:linear-gradient(135deg,#ff6b6b,#ee5a6f); color:white;
  padding:18px 50px; border-radius:30px; font-size:18px; font-weight:bold;
  border:none; display:none; box-shadow:0 5px 20px rgba(238,90,111,0.4);
  animation:pulse 2s infinite;
}
@keyframes pulse { 0%,100%{transform:translateX(-50%) scale(1);} 50%{transform:translateX(-50%) scale(1.05);} }
.cta.show { display:block; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div class="hint" id="hint">ç‚¹å‡»ç“¶å­é€‰æ‹©ï¼Œå€’æ°´åˆ°åŒè‰²ç“¶</div>
<button class="cta" id="cta" onclick="download()">ğŸ§§ é¢†çº¢åŒ…ä¸‹è½½</button>

<script>
// å“åº”å¼ç”»å¸ƒè®¾ç½®
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width, height, scale;

function resize() {
  width = canvas.width = window.innerWidth * window.devicePixelRatio;
  height = canvas.height = window.innerHeight * window.devicePixelRatio;
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
  scale = width < height ? width / 375 : height / 812; // ä»¥iPhone Xä¸ºåŸºå‡†
}
window.addEventListener('resize', resize);
resize();

// é¢œè‰²é…ç½®
const COLORS = [
  { name:'red', main:'#FF4757', light:'#FF6B81', dark:'#C44569', glow:'rgba(255,71,87,0.6)' },
  { name:'blue', main:'#3742FA', light:'#5352ED', dark:'#2F3542', glow:'rgba(55,66,250,0.6)' },
  { name:'green', main:'#2ED573', light:'#7BED9F', dark:'#218C74', glow:'rgba(46,213,115,0.6)' }
];

// çŠ¶æ€
let bottles = [];
let packets = [];
let selectedIdx = null;
let pouringAnim = null;
let particles = [];
let isAnimating = false;

// ç»˜åˆ¶åœ†è§’çŸ©å½¢å·¥å…·
function roundRect(ctx, x, y, w, h, r) {
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.lineTo(x+w-rr, y);
  ctx.quadraticCurveTo(x+w, y, x+w, y+rr);
  ctx.lineTo(x+w, y+h-rr);
  ctx.quadraticCurveTo(x+w, y+h, x+w-rr, y+h);
  ctx.lineTo(x+rr, y+h);
  ctx.quadraticCurveTo(x, y+h, x, y+h-rr);
  ctx.lineTo(x, y+rr);
  ctx.quadraticCurveTo(x, y, x+rr, y);
  ctx.closePath();
}

// ç“¶å­ç±» - ç²¾è‡´ç»ç’ƒç“¶æ ·å¼
class Bottle {
  constructor(x, y, w, h, colors) {
    this.x = x; this.y = y; this.w = w; this.h = h;
    this.colors = colors || []; // ä»åº•åˆ°é¡¶
    this.selected = false;
    this.corked = false;
    this.flying = false;
    this.flyProgress = 0;
    this.targetX = 0; this.targetY = 0;
  }

  draw(ctx) {
    if (this.flying) {
      // é£è¡ŒåŠ¨ç”»
      this.flyProgress += 0.05;
      const t = this.flyProgress;
      const curX = this.x + (this.targetX - this.x) * t;
      const curY = this.y + (this.targetY - this.y) * t - Math.sin(t*Math.PI) * 100; // æŠ›ç‰©çº¿
      const s = 1 - t * 0.3;
      
      ctx.save();
      ctx.translate(curX + this.w/2, curY + this.h/2);
      ctx.scale(s, s);
      ctx.rotate(t * Math.PI * 2);
      this.drawShape(ctx, -this.w/2, -this.h/2, this.w, this.h);
      ctx.restore();
      return;
    }

    this.drawShape(ctx, this.x, this.y, this.w, this.h);
  }

  drawShape(ctx, x, y, w, h) {
    const cx = x + w/2;
    const bw = w * 0.7; // ç“¶èº«å®½åº¦ï¼ˆç»†ç“¶å£ï¼‰
    
    // è£å‰ªåŒºåŸŸï¼ˆç“¶å†…ï¼‰- ç»˜åˆ¶æ¶²ä½“
    ctx.save();
    this.clipBottle(ctx, x, y, w, h);
    
    // æ¶²ä½“å±‚ï¼ˆä»ä¸‹å¾€ä¸Šï¼‰
    const liquidH = (h * 0.75) / 4; // 4å±‚æ¶²ä½“é«˜åº¦
    const bottomY = y + h * 0.85;
    
    this.colors.forEach((col, idx) => {
      const ly = bottomY - (idx + 1) * liquidH;
      
      // æ¶²ä½“æ¸å˜
      const grad = ctx.createLinearGradient(x, ly, x, ly + liquidH);
      grad.addColorStop(0, col.dark);
      grad.addColorStop(0.5, col.main);
      grad.addColorStop(1, col.light);
      
      ctx.fillStyle = grad;
      
      // ç»˜åˆ¶æ¶²ä½“ï¼ˆå¸¦åœ†è§’åº•éƒ¨ï¼‰
      ctx.beginPath();
      if (idx === 0) {
        // æœ€åº•å±‚æœ‰åœ†åº•
        roundRect(ctx, x + (w-bw)/2, ly, bw, liquidH + 10, 10);
      } else {
        ctx.fillRect(x + (w-bw)/2, ly, bw, liquidH);
      }
      ctx.fill();
      
      // æ¶²é¢é«˜å…‰ï¼ˆç™½è‰²æ¨ªçº¿ï¼‰
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.fillRect(x + (w-bw)/2 + 5, ly, bw - 10, 2);
      
      // å±‚é—´é˜´å½±
      if (idx > 0) {
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(x + (w-bw)/2, ly + liquidH - 2, bw, 2);
      }
    });
    ctx.restore();
    
    // ç»˜åˆ¶ç»ç’ƒå¤–å£³
    this.drawGlassShell(ctx, x, y, w, h);
    
    // è½¯æœ¨å¡ï¼ˆæ»¡ç“¶æ˜¾ç¤ºï¼‰
    if (this.colors.length === 4 && this.isUniform()) {
      this.drawCork(ctx, cx, y + h * 0.12, w * 0.5);
    }
  }

  clipBottle(ctx, x, y, w, h) {
    ctx.beginPath();
    this.bottlePath(ctx, x, y, w, h);
    ctx.clip();
  }

  bottlePath(ctx, x, y, w, h) {
    const cx = x + w/2;
    const neckW = w * 0.4;
    const neckH = h * 0.2;
    const bodyW = w * 0.75;
    const bodyH = h * 0.65;
    const shoulderH = h * 0.15;
    
    // ç“¶å£
    ctx.moveTo(cx - neckW/2, y);
    ctx.lineTo(cx + neckW/2, y);
    // ç“¶è‚©ï¼ˆè¿‡æ¸¡åˆ°ç“¶èº«ï¼‰
    ctx.lineTo(cx + bodyW/2, y + neckH);
    ctx.lineTo(cx + bodyW/2, y + neckH + bodyH - 15);
    // ç“¶åº•ï¼ˆåœ†è§’ï¼‰
    ctx.quadraticCurveTo(cx + bodyW/2, y + h, cx, y + h);
    ctx.quadraticCurveTo(cx - bodyW/2, y + h, cx - bodyW/2, y + neckH + bodyH - 15);
    ctx.lineTo(cx - bodyW/2, y + neckH);
    ctx.closePath();
  }

  drawGlassShell(ctx, x, y, w, h) {
    ctx.save();
    
    // ç»ç’ƒè¾¹æ¡†ï¼ˆå‘å…‰ï¼‰
    ctx.beginPath();
    this.bottlePath(ctx, x, y, w, h);
    ctx.strokeStyle = this.selected ? '#FFD700' : 'rgba(255,255,255,0.6)';
    ctx.lineWidth = this.selected ? 3 : 2;
    ctx.shadowBlur = this.selected ? 20 : 10;
    ctx.shadowColor = this.selected ? 'rgba(255,215,0,0.8)' : 'rgba(100,200,255,0.3)';
    ctx.stroke();
    ctx.shadowBlur = 0;
    
    // ç»ç’ƒå¡«å……ï¼ˆææ·¡ï¼‰
    ctx.fillStyle = 'rgba(200,230,255,0.05)';
    ctx.fill();
    
    // é«˜å…‰ï¼ˆå·¦ä¾§ï¼‰
    ctx.beginPath();
    const cx = x + w/2;
    ctx.moveTo(cx - w*0.15, y + h*0.1);
    ctx.lineTo(cx - w*0.15, y + h*0.8);
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    ctx.stroke();
    
    // æ¬¡é«˜å…‰
    ctx.beginPath();
    ctx.moveTo(cx + w*0.1, y + h*0.15);
    ctx.lineTo(cx + w*0.1, y + h*0.5);
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    ctx.restore();
  }

  drawCork(ctx, x, y, w) {
    const h = w * 0.6;
    
    // è½¯æœ¨å¡æ¸å˜
    const grad = ctx.createLinearGradient(x - w/2, y, x + w/2, y);
    grad.addColorStop(0, '#C4915C');
    grad.addColorStop(0.5, '#E6B88A');
    grad.addColorStop(1, '#C4915C');
    
    ctx.fillStyle = grad;
    roundRect(ctx, x - w/2, y - h, w, h, 5);
    ctx.fill();
    
    // é¡¶éƒ¨æ¤­åœ†
    ctx.fillStyle = '#D4A574';
    ctx.beginPath();
    ctx.ellipse(x, y - h, w/2, 5, 0, 0, Math.PI*2);
    ctx.fill();
    
    // çº¹ç†
    ctx.strokeStyle = 'rgba(0,0,0,0.1)';
    ctx.lineWidth = 1;
    for(let i=-w/3; i<=w/3; i+=w/6) {
      ctx.beginPath();
      ctx.moveTo(x + i, y - h + 5);
      ctx.lineTo(x + i + 3, y - 5);
      ctx.stroke();
    }
  }

  isUniform() {
    if (this.colors.length === 0) return false;
    return this.colors.every(c => c.name === this.colors[0].name);
  }

  contains(mx, my) {
    // ç®€åŒ–ä¸ºçŸ©å½¢æ£€æµ‹
    return mx > this.x && mx < this.x + this.w &&
           my > this.y && my < this.y + this.h;
  }

  flyTo(targetX, targetY) {
    this.flying = true;
    this.targetX = targetX;
    this.targetY = targetY;
  }
}

// å€’æ°´åŠ¨ç”» - çœŸå®ç‰©ç†æŠ›ç‰©çº¿
class PourWater {
  constructor(fromBottle, toBottle, color) {
    this.from = fromBottle;
    this.to = toBottle;
    this.color = color;
    this.progress = 0;
    this.droplets = [];
    this.active = true;
    
    // è®¡ç®—ç“¶å£åæ ‡
    this.x1 = fromBottle.x + fromBottle.w/2;
    this.y1 = fromBottle.y + fromBottle.h * 0.15; // ç“¶å£ä½ç½®
    this.x2 = toBottle.x + toBottle.w/2;
    this.y2 = toBottle.y + toBottle.h * 0.15;
    
    // æŠ›ç‰©çº¿æ§åˆ¶ç‚¹ï¼ˆé‡åŠ›æ•ˆæœï¼‰
    this.cpX = (this.x1 + this.x2) / 2;
    this.cpY = Math.max(this.y1, this.y2) + Math.abs(this.x2 - this.x1) * 0.3;
  }

  update() {
    this.progress += 0.025;
    
    // ç”Ÿæˆæ°´æ»´ï¼ˆæŠ›ç‰©çº¿è¿åŠ¨ï¼‰
    if (this.progress < 0.8 && Math.random() > 0.3) {
      const t = this.progress + Math.random() * 0.1;
      // äºŒæ¬¡è´å¡å°”å…¬å¼
      const x = (1-t)*(1-t)*this.x1 + 2*(1-t)*t*this.cpX + t*t*this.x2;
      const y = (1-t)*(1-t)*this.y1 + 2*(1-t)*t*this.cpY + t*t*this.y2;
      
      this.droplets.push({
        x, y, vx: (Math.random()-0.5)*2, vy: Math.random()*3,
        size: 3 + Math.random()*4, life: 1
      });
    }
    
    // æ›´æ–°æ°´æ»´
    this.droplets.forEach(d => {
      d.x += d.vx;
      d.y += d.vy; // é‡åŠ›ä¸‹è½
      d.vy += 0.2;
      d.life -= 0.02;
    });
    this.droplets = this.droplets.filter(d => d.life > 0 && d.y < this.y2 + 50);
    
    if (this.progress >= 1 && this.droplets.length === 0) {
      this.active = false;
    }
  }

  draw(ctx) {
    if (!this.active) return;
    
    // æŠ›ç‰©çº¿æ°´æµï¼ˆç²—çº¿ï¼‰
    ctx.beginPath();
    ctx.moveTo(this.x1, this.y1);
    ctx.quadraticCurveTo(this.cpX, this.cpY, this.x2, this.y2);
    ctx.strokeStyle = this.color.main;
    ctx.lineWidth = 8;
    ctx.lineCap = 'round';
    ctx.shadowBlur = 10;
    ctx.shadowColor = this.color.glow;
    ctx.stroke();
    ctx.shadowBlur = 0;
    
    // æ°´æµæ ¸å¿ƒï¼ˆäº®ï¼‰
    ctx.beginPath();
    ctx.moveTo(this.x1, this.y1);
    ctx.quadraticCurveTo(this.cpX, this.cpY, this.x2, this.y2);
    ctx.strokeStyle = this.color.light;
    ctx.lineWidth = 4;
    ctx.stroke();
    
    // æ°´æ»´ç²’å­
    this.droplets.forEach(d => {
      ctx.beginPath();
      ctx.arc(d.x, d.y, d.size, 0, Math.PI*2);
      ctx.fillStyle = this.color.light;
      ctx.globalAlpha = d.life;
      ctx.fill();
      ctx.globalAlpha = 1;
    });
    
    // è½å…¥æ¶Ÿæ¼ª
    if (this.progress > 0.3 && this.progress < 0.9) {
      ctx.beginPath();
      ctx.ellipse(this.x2, this.y2, 15*(1-this.progress), 5*(1-this.progress), 0, 0, Math.PI*2);
      ctx.strokeStyle = this.color.main;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }
}

// çº¢åŒ…ç±»
class RedPacket {
  constructor(x, y, colorInfo) {
    this.x = x; this.y = y; this.color = colorInfo;
    this.collected = false;
    this.scale = 1;
  }

  draw(ctx) {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.scale(this.scale, this.scale);
    
    const w = 70, h = 85;
    
    // å‘å…‰ï¼ˆæœªæ”¶é›†ï¼‰
    if (!this.collected) {
      ctx.shadowBlur = 15 + Math.sin(Date.now()/200)*5;
      ctx.shadowColor = 'gold';
    } else {
      ctx.filter = 'grayscale(0.6)';
    }
    
    // çº¢åŒ…ä¸»ä½“
    const grad = ctx.createLinearGradient(0, -h/2, 0, h/2);
    grad.addColorStop(0, '#FF6B6B');
    grad.addColorStop(1, '#EE5A6F');
    ctx.fillStyle = grad;
    roundRect(ctx, -w/2, -h/2, w, h, 8);
    ctx.fill();
    ctx.shadowBlur = 0;
    
    // ç›–å­
    ctx.fillStyle = '#E54848';
    ctx.beginPath();
    ctx.moveTo(-w/2, -h/2);
    ctx.lineTo(w/2, -h/2);
    ctx.lineTo(w/2, -h/2 + 25);
    ctx.quadraticCurveTo(w/4, -h/2 + 20, 0, -h/2 + 25);
    ctx.quadraticCurveTo(-w/4, -h/2 + 20, -w/2, -h/2 + 25);
    ctx.fill();
    
    // é‡‘å¸
    ctx.fillStyle = '#FFD700';
    ctx.beginPath();
    ctx.arc(0, 5, 16, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = '#FFA500';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Â¥
    ctx.fillStyle = '#EE5A6F';
    ctx.font = 'bold 18px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Â¥', 0, 5);
    
    ctx.restore();
  }

  collect() {
    this.collected = true;
    // ç¼©æ”¾åŠ¨ç”»
    const animate = () => {
      this.scale += (0.85 - this.scale) * 0.1;
      if (Math.abs(this.scale - 0.85) > 0.01) requestAnimationFrame(animate);
    };
    animate();
    
    // ç²’å­çˆ†å‘
    for(let i=0; i<20; i++) {
      const angle = (i/20) * Math.PI * 2;
      const speed = 5 + Math.random()*5;
      particles.push({
        x: this.x, y: this.y,
        vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed,
        life: 1, color: '#FFD700', size: 4
      });
    }
  }
}

// åˆå§‹åŒ–æ¸¸æˆ
function init() {
  bottles = [];
  packets = [];
  particles = [];
  selectedIdx = null;
  isAnimating = false;
  
  // è®¡ç®—å¸ƒå±€ï¼ˆåŸºäºå±å¹•å°ºå¯¸ï¼‰
  const cx = width / 2;
  const cy = height / 2;
  
  // çº¢åŒ…ä½ç½®ï¼ˆé¡¶éƒ¨ï¼‰
  const pktY = height * 0.12;
  const pktGap = Math.min(width * 0.25, 100);
  COLORS.forEach((col, i) => {
    packets.push(new RedPacket(cx + (i-1)*pktGap, pktY, col));
  });
  
  // ç“¶å­å¸ƒå±€ï¼ˆåº•éƒ¨ï¼Œå“åº”å¼ï¼‰
  const bottleW = Math.min(width * 0.18, 80);
  const bottleH = bottleW * 2.2;
  const gap = width * 0.05;
  const totalW = 4 * bottleW + 3 * gap;
  const startX = (width - totalW) / 2;
  const bottleY = height * 0.55;
  
  // å¯è§£çš„åˆå§‹å¸ƒå±€ï¼ˆç¡®ä¿èƒ½é€šå…³ï¼‰
  // ç“¶å­1: [çº¢,è“] ç“¶å­2: [è“,ç»¿] ç“¶å­3: [ç»¿,çº¢] ç“¶å­4: []
  const layouts = [
    [COLORS[0], COLORS[1]], // çº¢-è“
    [COLORS[1], COLORS[2]], // è“-ç»¿  
    [COLORS[2], COLORS[0]], // ç»¿-çº¢
    [] // ç©ºç“¶
  ];
  
  layouts.forEach((cols, i) => {
    bottles.push(new Bottle(startX + i*(bottleW+gap), bottleY, bottleW, bottleH, cols));
  });
}

// ç‚¹å‡»å¤„ç†
canvas.addEventListener('click', (e) => {
  if (isAnimating || pouringAnim) return;
  
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * window.devicePixelRatio;
  const y = (e.clientY - rect.top) * window.devicePixelRatio;
  
  // æ£€æŸ¥ç‚¹å‡»
  const idx = bottles.findIndex(b => b.contains(x, y));
  if (idx === -1) return;
  
  const bottle = bottles[idx];
  
  // æœªé€‰æ‹©æ—¶ç‚¹å‡»
  if (selectedIdx === null) {
    if (bottle.colors.length === 0) {
      showHint('ç©ºç“¶å­ä¸èƒ½é€‰æ‹©', true);
      return;
    }
    bottle.selected = true;
    selectedIdx = idx;
    showHint('å†ç‚¹å‡»ç›®æ ‡ç“¶å­å€’æ°´');
  }
  // å–æ¶ˆé€‰æ‹©
  else if (selectedIdx === idx) {
    bottle.selected = false;
    selectedIdx = null;
    showHint('ç‚¹å‡»ç“¶å­é€‰æ‹©ï¼Œå€’æ°´åˆ°åŒè‰²ç“¶');
  }
  // å€’æ°´
  else {
    attemptPour(selectedIdx, idx);
  }
});

function attemptPour(fromIdx, toIdx) {
  const from = bottles[fromIdx];
  const to = bottles[toIdx];
  
  // æ£€æŸ¥è§„åˆ™
  if (to.colors.length >= 4) {
    showHint('ç›®æ ‡ç“¶å­å·²æ»¡', true);
    return;
  }
  
  const fromColor = from.colors[from.colors.length - 1];
  const toColor = to.colors[to.colors.length - 1];
  
  if (toColor && toColor.name !== fromColor.name) {
    showHint('é¢œè‰²ä¸åŒ¹é…ï¼Œåªèƒ½å€’åˆ°åŒè‰²æˆ–ç©ºç“¶', true);
    return;
  }
  
  // å¼€å§‹åŠ¨ç”»
  isAnimating = true;
  from.selected = false;
  selectedIdx = null;
  
  // åˆ›å»ºå€’æ°´åŠ¨ç”»
  pouringAnim = new PourWater(from, to, fromColor);
  
  // å»¶è¿Ÿæ‰§è¡Œé€»è¾‘
  setTimeout(() => {
    // ç§»åŠ¨é¢œè‰²ï¼ˆåªç§»åŠ¨é¡¶éƒ¨è¿ç»­çš„åŒè‰²å—ï¼‰
    let count = 0;
    const topColorName = fromColor.name;
    for (let i = from.colors.length - 1; i >= 0; i--) {
      if (from.colors[i].name === topColorName && to.colors.length < 4) {
        to.colors.push(from.colors[i]);
        from.colors.pop();
        count++;
      } else {
        break;
      }
    }
    
    // æ£€æŸ¥æ»¡ç“¶
    if (to.colors.length === 4 && to.colors.every(c => c.name === fromColor.name)) {
      setTimeout(() => {
        // æ‰¾åˆ°å¯¹åº”çº¢åŒ…å¹¶æ”¶é›†
        const packet = packets.find(p => p.color.name === fromColor.name && !p.collected);
        if (packet) {
          packet.collect();
          to.flyTo(packet.x, packet.y);
        }
        checkWin();
      }, 300);
    }
    
    isAnimating = false;
    pouringAnim = null;
    showHint('ç‚¹å‡»ç“¶å­é€‰æ‹©ï¼Œå€’æ°´åˆ°åŒè‰²ç“¶');
  }, 800);
}

function showHint(text, isError) {
  const hint = document.getElementById('hint');
  hint.textContent = text;
  hint.className = isError ? 'hint error' : 'hint';
  if (isError) {
    setTimeout(() => {
      hint.textContent = 'ç‚¹å‡»ç“¶å­é€‰æ‹©ï¼Œå€’æ°´åˆ°åŒè‰²ç“¶';
      hint.className = 'hint';
    }, 2000);
  }
}

function checkWin() {
  if (packets.every(p => p.collected)) {
    showHint('ğŸ‰ æ­å–œé€šå…³ï¼æ‰€æœ‰çº¢åŒ…å·²é¢†å–');
    document.getElementById('cta').classList.add('show');
  }
}

function download() {
  alert('è·³è½¬åˆ°åº”ç”¨å•†åº—ä¸‹è½½');
}

// æ¸²æŸ“å¾ªç¯
function render() {
  ctx.clearRect(0, 0, width, height);
  
  // èƒŒæ™¯æ¸å˜
  const grad = ctx.createLinearGradient(0, 0, 0, height);
  grad.addColorStop(0, '#1a3a5f');
  grad.addColorStop(1, '#0a1628');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, width, height);
  
  // ç»˜åˆ¶å€’æ°´åŠ¨ç”»
  if (pouringAnim) {
    pouringAnim.update();
    pouringAnim.draw(ctx);
  }
  
  // ç»˜åˆ¶ç“¶å­
  bottles.forEach(b => b.draw(ctx));
  
  // ç»˜åˆ¶çº¢åŒ…
  packets.forEach(p => p.draw(ctx));
  
  // ç»˜åˆ¶ç²’å­
  particles.forEach((p, i) => {
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.3; // é‡åŠ›
    p.life -= 0.02;
    
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
    ctx.fillStyle = p.color;
    ctx.globalAlpha = p.life;
    ctx.fill();
    ctx.globalAlpha = 1;
    
    if (p.life <= 0) particles.splice(i, 1);
  });
  
  requestAnimationFrame(render);
}

// å¯åŠ¨
init();
render();

// çª—å£å¤§å°æ”¹å˜æ—¶é‡æ–°å¸ƒå±€
window.addEventListener('resize', () => {
  resize();
  init(); // é‡æ–°å¸ƒå±€
});
</script>
</body>
</html>
