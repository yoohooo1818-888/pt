<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
<title>å€’æ°´çº¢åŒ…ç‰ˆ - Canvasç»˜åˆ¶</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; touch-action:manipulation; -webkit-tap-highlight-color:transparent; user-select:none; }
body { 
  width:100%; height:100vh; overflow:hidden;
  background: radial-gradient(ellipse at center, #1a2b4a 0%, #0a1628 100%);
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;
}
#gameCanvas { display:block; touch-action:none; }
.hint-box {
  position:absolute; top:20%; left:50%; transform:translateX(-50%);
  background:rgba(0,0,0,0.7); color:#fff;
  padding:12px 24px; border-radius:25px; font-size:16px;
  z-index:100; pointer-events:none; transition:opacity 0.3s;
  white-space:nowrap;
}
.celebration {
  position:absolute; top:0; left:0; width:100%; height:100%;
  pointer-events:none; z-index:50;
}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div class="hint-box" id="hint">ç‚¹å‡»ç“¶å­é€‰æ‹©ï¼Œå†ç‚¹å‡»å¦ä¸€ç“¶å­å€’æ°´</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width, height;

// å“åº”å¼ç”»å¸ƒ
function resize() {
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// æ¸¸æˆé…ç½®
const COLORS = [
  { name:'red', hex:'#FF4757', dark:'#C73E4A' },
  { name:'blue', hex:'#3742FA', dark:'#2A35C7' },
  { name:'green', hex:'#2ED573', dark:'#23AA5A' }
];

// ç“¶å­ç±» - çº¯Canvasç»˜åˆ¶
class Bottle {
  constructor(x, y, id, initialColors = []) {
    this.x = x;
    this.y = y;
    this.id = id;
    this.width = 70;
    this.height = 140;
    this.colors = initialColors; // ä»åº•åˆ°é¡¶
    this.selected = false;
    this.corked = false;
    this.corkY = -20; // è½¯æœ¨å¡åŠ¨ç”»ä½ç½®
    this.liquidLevel = 0; // ç”¨äºå¡«å……åŠ¨ç”»
    this.wavePhase = Math.random() * Math.PI * 2; // æ¶²é¢æ³¢æµª
  }

  draw(ctx) {
    const { x, y, width, height } = this;
    const centerX = x + width/2;
    
    // ç»˜åˆ¶æ¶²ä½“ï¼ˆåœ¨ç“¶èº«å†…éƒ¨ï¼‰
    ctx.save();
    ctx.beginPath();
    // ç“¶èº«å½¢çŠ¶è£å‰ªåŒºåŸŸ
    this.drawBottleShape(ctx, x, y, width, height);
    ctx.clip();
    
    // ç»˜åˆ¶å„å±‚æ¶²ä½“
    let currentY = y + height - 10; // åº•éƒ¨ç•™è¾¹
    this.colors.forEach((color, idx) => {
      const layerHeight = (height - 20) / 4;
      const wave = Math.sin(this.wavePhase + idx * 0.5) * 3;
      
      // æ¶²ä½“æ¸å˜
      const grad = ctx.createLinearGradient(centerX, currentY - layerHeight, centerX, currentY);
      grad.addColorStop(0, color.hex);
      grad.addColorStop(1, color.dark);
      ctx.fillStyle = grad;
      
      // ç»˜åˆ¶æ¶²é¢ï¼ˆå¸¦æ³¢æµªï¼‰
      ctx.beginPath();
      ctx.moveTo(x + 5, currentY);
      ctx.lineTo(x + width - 5, currentY);
      ctx.lineTo(x + width - 5, currentY - layerHeight + 5);
      // ä¸Šè¾¹ç¼˜æ³¢æµª
      for(let i=0; i<=10; i++) {
        const px = x + 5 + (width-10) * (i/10);
        const py = currentY - layerHeight + Math.sin(this.wavePhase + i*0.5) * 2;
        ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fill();
      
      // æ¶²ä½“è¡¨é¢é«˜å…‰
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.fillRect(x + 10, currentY - layerHeight + 2, width - 20, 2);
      
      currentY -= layerHeight;
    });
    ctx.restore();
    
    // ç»˜åˆ¶ç»ç’ƒç“¶èº«ï¼ˆåŠé€æ˜ç»ç’ƒæ•ˆæœï¼‰
    this.drawBottleShape(ctx, x, y, width, height);
    
    // ç»ç’ƒè¾¹æ¡†ï¼ˆå‘å…‰æ•ˆæœï¼‰
    ctx.strokeStyle = this.selected ? '#FFD700' : 'rgba(255,255,255,0.4)';
    ctx.lineWidth = this.selected ? 3 : 2;
    ctx.shadowBlur = this.selected ? 20 : 10;
    ctx.shadowColor = this.selected ? 'rgba(255,215,0,0.5)' : 'rgba(100,200,255,0.3)';
    ctx.stroke();
    ctx.shadowBlur = 0;
    
    // ç»ç’ƒåå…‰ï¼ˆé«˜å…‰ï¼‰
    ctx.beginPath();
    ctx.moveTo(x + 15, y + 20);
    ctx.lineTo(x + 15, y + height - 30);
    ctx.lineWidth = 3;
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.stroke();
    
    // ç“¶å£é«˜å…‰
    ctx.beginPath();
    ctx.arc(centerX, y + 10, 25, Math.PI, 0);
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // ç»˜åˆ¶è½¯æœ¨å¡ï¼ˆæ»¡ç“¶åŠ¨ç”»ï¼‰
    if(this.corked || this.colors.length === 4) {
      if(this.corkY < 5) this.corkY += 2; // è½ä¸‹åŠ¨ç”»
      this.drawCork(ctx, centerX, y + this.corkY);
    }
    
    // é€‰ä¸­ç‰¹æ•ˆï¼ˆå¤–åœˆå‘å…‰ï¼‰
    if(this.selected) {
      ctx.beginPath();
      this.drawBottleShape(ctx, x-5, y-5, width+10, height+10);
      ctx.strokeStyle = 'rgba(255,215,0,0.3)';
      ctx.lineWidth = 4;
      ctx.stroke();
    }
  }

  drawBottleShape(ctx, x, y, w, h) {
    const r = 25; // åœ†è§’åŠå¾„
    ctx.beginPath();
    ctx.moveTo(x + w/2 - 15, y); // ç“¶å£å·¦
    ctx.lineTo(x + w/2 - 25, y + 20); // ç“¶è‚©
    // å·¦ä¾§èº«ä½“
    ctx.lineTo(x + r, y + 20);
    ctx.arcTo(x, y + 20, x, y + 20 + r, r);
    ctx.lineTo(x, y + h - r);
    ctx.arcTo(x, y + h, x + r, y + h, r);
    // åº•éƒ¨
    ctx.lineTo(x + w - r, y + h);
    ctx.arcTo(x + w, y + h, x + w, y + h - r, r);
    // å³ä¾§èº«ä½“
    ctx.lineTo(x + w, y + 20 + r);
    ctx.arcTo(x + w, y + 20, x + w - r, y + 20, r);
    ctx.lineTo(x + w/2 + 25, y + 20); // ç“¶è‚©
    ctx.lineTo(x + w/2 + 15, y); // ç“¶å£å³
    ctx.closePath();
  }

  drawCork(ctx, x, y) {
    // è½¯æœ¨å¡ä¸»ä½“
    const grad = ctx.createLinearGradient(x-15, y, x+15, y);
    grad.addColorStop(0, '#D4A574');
    grad.addColorStop(0.5, '#E6B88A');
    grad.addColorStop(1, '#C4915C');
    
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.roundRect(x - 20, y - 5, 40, 25, 5);
    ctx.fill();
    
    // è½¯æœ¨å¡é¡¶éƒ¨
    ctx.fillStyle = '#C4915C';
    ctx.beginPath();
    ctx.ellipse(x, y - 5, 20, 8, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // çº¹ç†çº¿
    ctx.strokeStyle = 'rgba(0,0,0,0.1)';
    ctx.lineWidth = 1;
    for(let i=-10; i<=10; i+=5) {
      ctx.beginPath();
      ctx.moveTo(x + i, y);
      ctx.lineTo(x + i, y + 15);
      ctx.stroke();
    }
  }

  contains(mx, my) {
    return mx > this.x && mx < this.x + this.width &&
           my > this.y && my < this.y + this.height;
  }

  update() {
    this.wavePhase += 0.05; // æ¶²é¢æ³¢åŠ¨
  }
}

// å€’æ°´æµä½“åŠ¨ç”»ç±»
class PouringLiquid {
  constructor(fromBottle, toBottle, color) {
    this.from = fromBottle;
    this.to = toBottle;
    this.color = color;
    this.progress = 0;
    this.particles = [];
    this.active = true;
    
    // è®¡ç®—ç“¶å£ä½ç½®
    this.x1 = fromBottle.x + fromBottle.width/2;
    this.y1 = fromBottle.y + 10;
    this.x2 = toBottle.x + toBottle.width/2;
    this.y2 = toBottle.y + 10;
  }

  update() {
    this.progress += 0.03;
    
    // ç”ŸæˆæµåŠ¨ç²’å­
    if(this.progress < 0.8 && Math.random() > 0.3) {
      const t = this.progress % 1;
      const x = this.x1 + (this.x2 - this.x1) * t;
      const y = this.y1 + (this.y2 - this.y1) * t + Math.sin(t * Math.PI) * 30;
      this.particles.push({ x, y, size: 4 + Math.random() * 4, life: 1 });
    }
    
    // æ›´æ–°ç²’å­
    this.particles.forEach(p => {
      p.y += 2;
      p.life -= 0.05;
    });
    this.particles = this.particles.filter(p => p.life > 0);
    
    if(this.progress >= 1 && this.particles.length === 0) {
      this.active = false;
    }
  }

  draw(ctx) {
    if(!this.active) return;
    
    const { x1, y1, x2, y2, color } = this;
    
    // ç»˜åˆ¶æµæ›²çº¿ï¼ˆè´å¡å°”æ›²çº¿ï¼‰
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    const cpX = (x1 + x2) / 2;
    const cpY = Math.max(y1, y2) + 50; // æ§åˆ¶ç‚¹å‘ä¸‹å¼¯æ›²ï¼ˆé‡åŠ›æ•ˆæœï¼‰
    ctx.quadraticCurveTo(cpX, cpY, x2, y2);
    
    ctx.strokeStyle = color.hex;
    ctx.lineWidth = 8;
    ctx.lineCap = 'round';
    ctx.shadowBlur = 10;
    ctx.shadowColor = color.hex;
    ctx.stroke();
    ctx.shadowBlur = 0;
    
    // ç»˜åˆ¶æµåŠ¨ç²’å­ï¼ˆæ°´æ»´æ•ˆæœï¼‰
    this.particles.forEach(p => {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fillStyle = color.hex;
      ctx.globalAlpha = p.life;
      ctx.fill();
      ctx.globalAlpha = 1;
    });
    
    // ç›®æ ‡ç“¶å£æ¶Ÿæ¼ªæ•ˆæœ
    if(this.progress > 0.3 && this.progress < 0.9) {
      ctx.beginPath();
      ctx.arc(x2, y2, 5 + Math.sin(this.progress * 10) * 3, 0, Math.PI * 2);
      ctx.strokeStyle = color.hex;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }
}

// çº¢åŒ…ç±»
class RedPacket {
  constructor(x, color) {
    this.x = x;
    this.y = 60;
    this.color = color;
    this.collected = false;
    this.scale = 1;
    this.rotation = 0;
  }

  draw(ctx) {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rotation);
    ctx.scale(this.scale, this.scale);
    
    // çº¢åŒ…ä¸»ä½“ï¼ˆå¦‚æœå›¾ç‰‡åŠ è½½å¤±è´¥ç”¨ä»£ç ç»˜åˆ¶ï¼‰
    const w = 60, h = 80;
    
    // çº¢åŒ…å½¢çŠ¶
    ctx.fillStyle = '#FF4757';
    ctx.beginPath();
    ctx.roundRect(-w/2, -h/2, w, h, 10);
    ctx.fill();
    
    // ä¸Šéƒ¨ç›–å­ï¼ˆç¨å¾®æ·±ä¸€ç‚¹ï¼‰
    ctx.fillStyle = '#E63E4A';
    ctx.beginPath();
    ctx.moveTo(-w/2, -h/2);
    ctx.lineTo(w/2, -h/2);
    ctx.lineTo(w/2, -h/2 + 30);
    ctx.bezierCurveTo(w/4, -h/2 + 20, -w/4, -h/2 + 20, -w/2, -h/2 + 30);
    ctx.closePath();
    ctx.fill();
    
    // é‡‘å¸ç¬¦å·
    ctx.fillStyle = '#FFD700';
    ctx.beginPath();
    ctx.arc(0, 5, 18, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#FFA500';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Â¥ç¬¦å·
    ctx.fillStyle = '#FF4757';
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Â¥', 0, 5);
    
    // ç­‰å¾…æ”¶é›†æ—¶çš„å‘å…‰æ•ˆæœ
    if(!this.collected) {
      ctx.shadowBlur = 20 + Math.sin(Date.now() / 200) * 10;
      ctx.shadowColor = 'gold';
      ctx.strokeStyle = 'rgba(255,215,0,0.5)';
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
    
    ctx.restore();
  }

  collect() {
    this.collected = true;
    this.scale = 0.8;
  }
}

// æ¸¸æˆä¸»é€»è¾‘
class Game {
  constructor() {
    this.bottles = [];
    this.packets = [];
    this.selectedIndex = null;
    this.pouring = null; // å½“å‰å€’æµåŠ¨ç”»
    this.isAnimating = false;
    
    this.init();
    this.loop();
  }

  init() {
    // åˆ›å»ºçº¢åŒ…ï¼ˆé¡¶éƒ¨ï¼‰
    const packetWidth = width / 4;
    COLORS.forEach((color, idx) => {
      this.packets.push(new RedPacket(packetWidth * (idx + 1), color));
    });
    
    // åˆ›å»ºç“¶å­ï¼ˆåº•éƒ¨ä¸€æ’ï¼Œå±…ä¸­å¯¹é½ï¼‰
    const bottleWidth = 80;
    const gap = 20;
    const totalWidth = 4 * bottleWidth + 3 * gap;
    const startX = (width - totalWidth) / 2;
    
    const initColors = [
      [COLORS[0], COLORS[1], COLORS[1], COLORS[2]], // çº¢è“è“ç»¿
      [COLORS[2], COLORS[0], COLORS[0], COLORS[1]], // ç»¿çº¢çº¢è“
      [COLORS[1], COLORS[2], COLORS[2], COLORS[0]], // è“ç»¿ç»¿çº¢
      [] // ç©ºç“¶
    ];
    
    for(let i=0; i<4; i++) {
      this.bottles.push(new Bottle(
        startX + i * (bottleWidth + gap),
        height * 0.55,
        i,
        initColors[i]
      ));
    }
    
    // ç‚¹å‡»äº‹ä»¶
    canvas.addEventListener('click', (e) => this.handleClick(e));
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      this.handleClick(e.touches[0]);
    });
  }

  handleClick(e) {
    if(this.isAnimating) return;
    
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    // æ£€æŸ¥ç‚¹å‡»ç“¶å­
    const clickedIndex = this.bottles.findIndex(b => b.contains(x, y));
    if(clickedIndex === -1) return;
    
    const bottle = this.bottles[clickedIndex];
    
    if(this.selectedIndex === null) {
      if(bottle.colors.length === 0) {
        this.showHint('ç©ºç“¶å­ä¸èƒ½é€‰æ‹©', true);
        return;
      }
      bottle.selected = true;
      this.selectedIndex = clickedIndex;
      this.showHint('å†ç‚¹å‡»ç›®æ ‡ç“¶å­å€’æ°´');
    } else if(this.selectedIndex === clickedIndex) {
      bottle.selected = false;
      this.selectedIndex = null;
      this.showHint('ç‚¹å‡»ç“¶å­é€‰æ‹©ï¼Œå†ç‚¹å‡»å¦ä¸€ç“¶å­å€’æ°´');
    } else {
      this.attemptPour(this.selectedIndex, clickedIndex);
    }
  }

  attemptPour(fromIdx, toIdx) {
    const from = this.bottles[fromIdx];
    const to = this.bottles[toIdx];
    
    const fromColor = from.colors[from.colors.length - 1];
    const toColor = to.colors[to.colors.length - 1];
    
    if(to.colors.length >= 4) {
      this.showHint('ç“¶å­å·²æ»¡ï¼', true);
      return;
    }
    if(toColor && toColor.name !== fromColor.name) {
      this.showHint('åªèƒ½å€’å…¥ç›¸åŒé¢œè‰²çš„æ¶²ä½“', true);
      return;
    }
    
    // å¼€å§‹å€’æ°´åŠ¨ç”»
    this.isAnimating = true;
    from.selected = false;
    this.selectedIndex = null;
    
    this.pouring = new PouringLiquid(from, to, fromColor);
    
    // å»¶è¿Ÿæ‰§è¡Œæ•°æ®æ›´æ–°ï¼ˆé…åˆåŠ¨ç”»ï¼‰
    setTimeout(() => {
      to.colors.push(fromColor);
      from.colors.pop();
      
      // æ£€æŸ¥æ˜¯å¦æ»¡ç“¶
      if(to.colors.length === 4 && to.colors.every(c => c.name === fromColor.name)) {
        to.corked = true;
        setTimeout(() => this.collectToPacket(to, fromColor), 500);
      }
      
      this.showHint('ç‚¹å‡»ç“¶å­é€‰æ‹©ï¼Œå†ç‚¹å‡»å¦ä¸€ç“¶å­å€’æ°´');
    }, 500);
  }

  collectToPacket(bottle, color) {
    // æ‰¾åˆ°å¯¹åº”çº¢åŒ…
    const packet = this.packets.find(p => p.color.name === color.name && !p.collected);
    if(packet) {
      packet.collect();
      
      // ç“¶å­é£å…¥çº¢åŒ…åŠ¨ç”»
      const targetX = packet.x;
      const targetY = packet.y;
      
      const animateBottle = () => {
        bottle.x += (targetX - bottle.x) * 0.1;
        bottle.y += (targetY - 100 - bottle.y) * 0.1;
        bottle.scale = (bottle.scale || 1) * 0.95;
        
        if(Math.abs(bottle.x - targetX) > 5) {
          requestAnimationFrame(animateBottle);
        } else {
          bottle.visible = false; // éšè—ç“¶å­
          this.checkWin();
        }
      };
      animateBottle();
    }
    this.isAnimating = false;
  }

  checkWin() {
    if(this.packets.every(p => p.collected)) {
      this.showHint('æ­å–œé€šå…³ï¼', false, true);
      setTimeout(() => {
        document.getElementById('hint').innerHTML = 'ğŸ‰ ç‚¹å‡»ä¸‹è½½é¢†å–å¥–åŠ±';
        document.getElementById('hint').style.background = 'linear-gradient(135deg, #FF6B6B, #EE5A6F)';
      }, 1000);
    } else {
      this.isAnimating = false;
    }
  }

  showHint(text, isError = false, isWin = false) {
    const hint = document.getElementById('hint');
    hint.textContent = text;
    hint.style.color = isError ? '#FF6B6B' : '#fff';
    if(isWin) {
      hint.style.background = 'rgba(255,215,0,0.8)';
      hint.style.color = '#000';
    }
  }

  loop() {
    ctx.clearRect(0, 0, width, height);
    
    // ç»˜åˆ¶çº¢åŒ…
    this.packets.forEach(p => p.draw(ctx));
    
    // ç»˜åˆ¶å€’æµåŠ¨ç”»
    if(this.pouring && this.pouring.active) {
      this.pouring.update();
      this.pouring.draw(ctx);
    }
    
    // ç»˜åˆ¶ç“¶å­
    this.bottles.forEach(b => {
      if(b.visible !== false) {
        b.update();
        b.draw(ctx);
      }
    });
    
    requestAnimationFrame(() => this.loop());
  }
}

// å¯åŠ¨æ¸¸æˆ
let game;
setTimeout(() => {
  game = new Game();
}, 100);

// é˜²æ­¢é¡µé¢æ»šåŠ¨
document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
</script>
</body>
</html>
