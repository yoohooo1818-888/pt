<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
<title>å€’æ°´çº¢åŒ…ç‰ˆ</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; touch-action:none; -webkit-tap-highlight-color:transparent; user-select:none; }
body { 
  width:100%; height:100vh; overflow:hidden;
  background:#0a1628;
  display:flex; justify-content:center; align-items:center;
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;
}

/* æ¸¸æˆå®¹å™¨ - å›ºå®š720x1280ï¼Œå±…ä¸­æ˜¾ç¤º */
#gameContainer {
  width:720px; height:1280px;
  position:relative;
  background: radial-gradient(ellipse at center top, #1e3a5f 0%, #0a1628 60%, #050d18 100%);
  overflow:hidden;
  box-shadow:0 0 50px rgba(0,0,0,0.8);
}

/* é€‚é…ç§»åŠ¨ç«¯å…¨é¢å± */
@media (max-width:720px) {
  #gameContainer { width:100vw; height:100vh; }
}

canvas { display:block; }

/* UIå±‚ */
.ui-layer { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:100; }
.hint-box {
  position:absolute; top:200px; left:50%; transform:translateX(-50%);
  background:rgba(0,0,0,0.6); backdrop-filter:blur(10px);
  padding:20px 40px; border-radius:40px; border:1px solid rgba(255,255,255,0.2);
  color:#fff; font-size:28px; text-align:center; white-space:nowrap;
  transition:all 0.3s; pointer-events:auto;
}
.hint-box.error { color:#ff6b6b; border-color:#ff6b6b; animation:shake 0.4s; }
@keyframes shake { 0%,100%{transform:translateX(-50%) rotate(0);} 25%{transform:translateX(-50%) rotate(-3deg);} 75%{transform:translateX(-50%) rotate(3deg);} }

/* CTAæŒ‰é’® */
.cta-btn {
  position:absolute; bottom:100px; left:50%; transform:translateX(-50%);
  background:linear-gradient(135deg, #ff6b6b, #ee5a6f); color:white;
  font-size:32px; font-weight:bold; padding:25px 80px; border-radius:50px;
  border:none; cursor:pointer; pointer-events:auto;
  box-shadow:0 10px 40px rgba(238,90,111,0.4);
  animation:pulse 2s infinite; display:none;
}
@keyframes pulse { 0%,100%{transform:translateX(-50%) scale(1);} 50%{transform:translateX(-50%) scale(1.05);} }
.cta-btn.show { display:block; }
</style>
</head>
<body>

<div id="gameContainer">
  <canvas id="gameCanvas" width="720" height="1280"></canvas>
  <div class="ui-layer">
    <div class="hint-box" id="hint">ç‚¹å‡»ç“¶å­é€‰æ‹©ï¼Œå€’æ°´åˆ°åŒè‰²</div>
    <button class="cta-btn" id="cta" onclick="download()">ğŸ§§ é¢†çº¢åŒ…ä¸‹è½½</button>
  </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const width = 720, height = 1280;

// é¢œè‰²é…ç½®ï¼ˆæ›´é²œè‰³çš„é…è‰²ï¼‰
const COLORS = [
  { name:'red', main:'#ff4757', light:'#ff6b81', dark:'#c44569', glow:'rgba(255,71,87,0.6)' },
  { name:'blue', main:'#3742fa', light:'#5352ed', dark:'#2f3542', glow:'rgba(55,66,250,0.6)' },
  { name:'green', main:'#2ed573', light:'#7bed9f', dark:'#218c74', glow:'rgba(46,213,115,0.6)' }
];

// å·¥å…·å‡½æ•°ï¼šç»˜åˆ¶åœ†è§’çŸ©å½¢
function drawRoundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.lineTo(x+w-r, y); ctx.arcTo(x+w, y, x+w, y+r, r);
  ctx.lineTo(x+w, y+h-r); ctx.arcTo(x+w, y+h, x+w-r, y+h, r);
  ctx.lineTo(x+r, y+h); ctx.arcTo(x, y+h, x, y+h-r, r);
  ctx.lineTo(x, y+r); ctx.arcTo(x, y, x+r, y, r);
  ctx.closePath();
}

// ================= ç“¶å­ç±»ï¼ˆç²¾ä¿®ç‰ˆï¼‰ =================
class Bottle {
  constructor(x, y, id, colors = []) {
    this.x = x; this.y = y; this.id = id;
    this.width = 100; this.height = 220;
    this.colors = colors; // ä»åº•åˆ°ä¸Š
    this.selected = false;
    this.corked = false;
    this.liquidY = 0; // æ¶²é¢æ³¢åŠ¨åç§»
    this.targetLiquidY = 0;
  }

  draw(ctx) {
    const { x, y, w, h } = { x:this.x, y:this.y, w:this.width, h:this.height };
    const cx = x + w/2;
    
    // å…ˆç»˜åˆ¶æ¶²ä½“ï¼ˆåœ¨ç»ç’ƒåé¢ï¼‰
    this.drawLiquid(ctx);
    
    // ç»˜åˆ¶ç»ç’ƒç“¶èº«ï¼ˆé€æ˜æ•ˆæœï¼‰
    ctx.save();
    
    // ç“¶èº«å¤–è½®å»“ï¼ˆç”¨äºè£å‰ªå’Œæè¾¹ï¼‰
    drawRoundRect(ctx, x, y, w, h, 15);
    
    // ç»ç’ƒç“¶å¡«å……ï¼ˆææ·¡çš„é’è‰²é€æ˜ï¼‰
    ctx.fillStyle = 'rgba(200,230,255,0.08)';
    ctx.fill();
    
    // ç»ç’ƒè¾¹æ¡†ï¼ˆå†…å‘å…‰æ•ˆæœï¼‰
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.lineWidth = 3;
    ctx.stroke();
    
    // é€‰ä¸­çŠ¶æ€å¤–å‘å…‰
    if(this.selected) {
      ctx.shadowBlur = 30;
      ctx.shadowColor = 'rgba(255,215,0,0.8)';
      ctx.strokeStyle = '#ffd700';
      ctx.lineWidth = 4;
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
    
    // å·¦ä¾§é«˜å…‰ï¼ˆç»ç’ƒåå…‰ï¼‰
    ctx.beginPath();
    ctx.moveTo(x+15, y+30);
    ctx.lineTo(x+15, y+h-40);
    ctx.lineWidth = 4;
    ctx.strokeStyle = 'rgba(255,255,255,0.7)';
    ctx.lineCap = 'round';
    ctx.stroke();
    
    // å³ä¾§æ¬¡é«˜å…‰
    ctx.beginPath();
    ctx.moveTo(x+w-12, y+40);
    ctx.lineTo(x+w-12, y+h-50);
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    ctx.stroke();
    
    // ç“¶å£è¾¹ç¼˜
    ctx.beginPath();
    ctx.ellipse(cx, y+8, 35, 10, 0, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(200,230,255,0.15)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    ctx.restore();
    
    // ç»˜åˆ¶è½¯æœ¨å¡ï¼ˆå¦‚æœæ»¡ç“¶ï¼‰
    if(this.corked || (this.colors.length === 4 && this.isUniform())) {
      this.drawCork(ctx);
    }
  }

  drawLiquid(ctx) {
    if(this.colors.length === 0) return;
    
    const { x, y, width:w, height:h } = this;
    const liquidHeight = (h - 40) / 4; // æ¯å±‚é«˜åº¦
    const bottomY = y + h - 20; // æ¶²ä½“åº•éƒ¨
    
    // æ›´æ–°æ¶²é¢æ³¢åŠ¨
    this.liquidY += (this.targetLiquidY - this.liquidY) * 0.1;
    
    ctx.save();
    
    // è£å‰ªåˆ°ç“¶èº«å†…éƒ¨
    drawRoundRect(ctx, x+5, y+20, w-10, h-30, 10);
    ctx.clip();
    
    // ç»˜åˆ¶æ¯ä¸€å±‚æ¶²ä½“
    this.colors.forEach((color, idx) => {
      const baseY = bottomY - (idx + 1) * liquidHeight;
      const waveHeight = Math.sin(Date.now() * 0.003 + idx * 0.5) * 3; // æ³¢åŠ¨
      
      // æ¶²ä½“æ¸å˜
      const grad = ctx.createLinearGradient(x, baseY, x, baseY + liquidHeight);
      grad.addColorStop(0, color.dark);
      grad.addColorStop(0.3, color.main);
      grad.addColorStop(1, color.light);
      
      ctx.fillStyle = grad;
      
      // ç»˜åˆ¶æ¶²ä½“å—ï¼ˆå¸¦åœ†è§’å’Œæ³¢æµªé¡¶é¢ï¼‰
      ctx.beginPath();
      ctx.moveTo(x+5, baseY + 5);
      
      // é¡¶é¢æ³¢æµªï¼ˆåªæœ‰æœ€é¡¶å±‚æœ‰æ³¢åŠ¨ï¼‰
      if(idx === this.colors.length - 1) {
        for(let i=0; i<=10; i++) {
          const px = x + 5 + (w-10) * (i/10);
          const py = baseY + Math.sin(i * 0.5 + Date.now() * 0.005) * 2;
          ctx.lineTo(px, py);
        }
      } else {
        ctx.lineTo(x+w-5, baseY);
      }
      
      ctx.lineTo(x+w-5, baseY + liquidHeight);
      ctx.lineTo(x+5, baseY + liquidHeight);
      ctx.closePath();
      ctx.fill();
      
      // æ¶²ä½“è¡¨é¢é«˜å…‰ï¼ˆé‚£å±‚äº®çº¿ï¼‰
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.beginPath();
      if(idx === this.colors.length - 1) {
        for(let i=0; i<=10; i++) {
          const px = x + 5 + (w-10) * (i/10);
          const py = baseY + Math.sin(i * 0.5 + Date.now() * 0.005) * 2;
          ctx.lineTo(px, py + 3);
        }
      } else {
        ctx.moveTo(x+5, baseY + 3);
        ctx.lineTo(x+w-5, baseY + 3);
      }
      ctx.lineTo(x+w-5, baseY + 6);
      ctx.lineTo(x+5, baseY + 6);
      ctx.fill();
      
      // å±‚é—´åˆ†ç•Œçº¿ï¼ˆæ·¡æ·¡çš„é˜´å½±ï¼‰
      if(idx > 0) {
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(x+5, baseY + liquidHeight - 2, w-10, 2);
      }
    });
    
    ctx.restore();
  }

  drawCork(ctx) {
    const { x, y, width:w } = this;
    const cx = x + w/2;
    const cy = y - 5;
    
    // è½¯æœ¨å¡ä¸»ä½“ï¼ˆåœ†è§’çŸ©å½¢ï¼‰
    const corkW = 50, corkH = 35;
    
    // æœ¨çº¹æ¸å˜
    const grad = ctx.createLinearGradient(cx-corkW/2, cy, cx+corkW/2, cy);
    grad.addColorStop(0, '#d4a574');
    grad.addColorStop(0.5, '#e6b88a');
    grad.addColorStop(1, '#c4915c');
    
    ctx.fillStyle = grad;
    drawRoundRect(ctx, cx-corkW/2, cy, corkW, corkH, 8);
    ctx.fill();
    
    // è½¯æœ¨å¡é¡¶é¢ï¼ˆæ¤­åœ†ï¼Œæœ‰åšåº¦æ„Ÿï¼‰
    ctx.fillStyle = '#e6b88a';
    ctx.beginPath();
    ctx.ellipse(cx, cy, corkW/2, 10, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = '#b8956a';
    ctx.lineWidth = 1;
    ctx.stroke();
    
    // æœ¨çº¹çº¿æ¡ï¼ˆçº¹ç†ç»†èŠ‚ï¼‰
    ctx.strokeStyle = 'rgba(0,0,0,0.15)';
    ctx.lineWidth = 1;
    for(let i=-15; i<=15; i+=8) {
      ctx.beginPath();
      ctx.moveTo(cx+i, cy+5);
      ctx.lineTo(cx+i+3, cy+corkH-5);
      ctx.stroke();
    }
  }

  isUniform() {
    if(this.colors.length === 0) return false;
    return this.colors.every(c => c.name === this.colors[0].name);
  }

  contains(mx, my) {
    return mx > this.x && mx < this.x + this.width &&
           my > this.y && my < this.y + this.height;
  }
}

// ================= å€’æ°´åŠ¨ç”»ç±»ï¼ˆç²¾ä¿®ç‰ˆï¼‰ =================
class PourAnimation {
  constructor(fromBottle, toBottle, color) {
    this.from = fromBottle;
    this.to = toBottle;
    this.color = color;
    this.progress = 0;
    this.particles = [];
    this.active = true;
    
    // è®¡ç®—åæ ‡
    this.x1 = fromBottle.x + fromBottle.width/2;
    this.y1 = fromBottle.y + 15;
    this.x2 = toBottle.x + toBottle.width/2;
    this.y2 = toBottle.y + 15;
  }

  update() {
    this.progress += 0.025;
    
    // ç”Ÿæˆæ°´æ»´ç²’å­
    if(this.progress < 0.8 && Math.random() > 0.4) {
      const t = this.progress;
      // è´å¡å°”æ›²çº¿æ’å€¼
      const cpX = (this.x1 + this.x2) / 2;
      const cpY = Math.max(this.y1, this.y2) + 80;
      const x = (1-t)*(1-t)*this.x1 + 2*(1-t)*t*cpX + t*t*this.x2;
      const y = (1-t)*(1-t)*this.y1 + 2*(1-t)*t*cpY + t*t*this.y2;
      
      this.particles.push({
        x, y: y + Math.random()*20,
        vx: (Math.random()-0.5)*2,
        vy: Math.random()*5 + 2,
        size: 4 + Math.random()*6,
        life: 1,
        color: this.color
      });
    }
    
    // æ›´æ–°ç²’å­
    this.particles.forEach(p => {
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.3; // é‡åŠ›
      p.life -= 0.03;
    });
    this.particles = this.particles.filter(p => p.life > 0);
    
    if(this.progress >= 1 && this.particles.length === 0) {
      this.active = false;
    }
  }

  draw(ctx) {
    if(!this.active) return;
    
    const { x1, y1, x2, y2, color } = this;
    const progress = Math.min(this.progress, 1);
    
    // ä¸»æ°´æµï¼ˆç²—ï¼‰
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    const cpX = (x1 + x2) / 2;
    const cpY = Math.max(y1, y2) + 100;
    
    // ç»˜åˆ¶åˆ°å½“å‰è¿›åº¦ä½ç½®
    const t = progress;
    const curX = (1-t)*(1-t)*x1 + 2*(1-t)*t*cpX + t*t*x2;
    const curY = (1-t)*(1-t)*y1 + 2*(1-t)*t*cpY + t*t*y2;
    
    ctx.quadraticCurveTo(cpX, cpY, curX, curY);
    ctx.strokeStyle = color.main;
    ctx.lineWidth = 12;
    ctx.lineCap = 'round';
    ctx.shadowBlur = 15;
    ctx.shadowColor = color.glow;
    ctx.stroke();
    ctx.shadowBlur = 0;
    
    // æ°´æµæ ¸å¿ƒï¼ˆäº®ï¼‰
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.quadraticCurveTo(cpX, cpY, curX, curY);
    ctx.strokeStyle = color.light;
    ctx.lineWidth = 6;
    ctx.stroke();
    
    // æ°´æ»´ç²’å­
    this.particles.forEach(p => {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
      ctx.fillStyle = p.color.main;
      ctx.globalAlpha = p.life;
      ctx.fill();
      ctx.globalAlpha = 1;
    });
    
    // è½å…¥ç‚¹æ¶Ÿæ¼ª
    if(progress > 0.3 && progress < 0.9) {
      ctx.beginPath();
      ctx.ellipse(x2, y2, 20*(1-progress), 8*(1-progress), 0, 0, Math.PI*2);
      ctx.strokeStyle = color.main;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }
}

// ================= çº¢åŒ…ç±» =================
class RedPacket {
  constructor(x, y, colorInfo) {
    this.x = x; this.y = y;
    this.color = colorInfo;
    this.collected = false;
    this.scale = 1;
    this.openProgress = 0;
  }

  draw(ctx) {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.scale(this.scale, this.scale);
    
    // çº¢åŒ…ä¸»ä½“ï¼ˆåœ†è§’çŸ©å½¢ï¼‰
    const w = 90, h = 110;
    
    // å¦‚æœæ˜¯å·²æ”¶é›†çŠ¶æ€ï¼Œå˜ç°
    if(this.collected) {
      ctx.filter = 'grayscale(0.8) brightness(0.7)';
    } else {
      // ç­‰å¾…çŠ¶æ€çš„å‘å…‰
      ctx.shadowBlur = 20 + Math.sin(Date.now()*0.005)*10;
      ctx.shadowColor = 'gold';
    }
    
    // çº¢åŒ…çº¢è‰²æ¸å˜
    const grad = ctx.createLinearGradient(0, -h/2, 0, h/2);
    grad.addColorStop(0, '#ff6b6b');
    grad.addColorStop(1, '#ee5a6f');
    ctx.fillStyle = grad;
    drawRoundRect(ctx, -w/2, -h/2, w, h, 12);
    ctx.fill();
    ctx.shadowBlur = 0;
    
    // ä¸Šéƒ¨ç›–å­ï¼ˆç¨æ·±ï¼‰
    ctx.fillStyle = '#e54848';
    ctx.beginPath();
    ctx.moveTo(-w/2, -h/2);
    ctx.lineTo(w/2, -h/2);
    ctx.lineTo(w/2, -h/2 + 35);
    ctx.bezierCurveTo(w/4, -h/2 + 25, -w/4, -h/2 + 25, -w/2, -h/2 + 35);
    ctx.closePath();
    ctx.fill();
    
    // é‡‘è‰²åœ†åœˆ
    ctx.fillStyle = '#ffd700';
    ctx.beginPath();
    ctx.arc(0, 5, 22, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = '#ffb700';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Â¥ç¬¦å·
    ctx.fillStyle = '#ee5a6f';
    ctx.font = 'bold 24px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Â¥', 0, 5);
    
    // å·²æ”¶é›†å°ç« æ•ˆæœ
    if(this.collected) {
      ctx.strokeStyle = 'rgba(255,215,0,0.6)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(0, 0, 35, 0, Math.PI*2);
      ctx.stroke();
      ctx.fillStyle = 'rgba(255,215,0,0.8)';
      ctx.font = 'bold 16px Arial';
      ctx.fillText('å·²é¢†å–', 0, 0);
    }
    
    ctx.restore();
  }

  collect() {
    this.collected = true;
    // æ”¶é›†åŠ¨ç”»
    let s = 1;
    const animate = () => {
      s += (0.85 - s) * 0.1;
      this.scale = s;
      if(Math.abs(s - 0.85) > 0.01) requestAnimationFrame(animate);
    };
    animate();
  }
}

// ================= æ¸¸æˆä¸»é€»è¾‘ =================
class Game {
  constructor() {
    this.bottles = [];
    this.packets = [];
    this.selectedIndex = null;
    this.pouring = null;
    this.isAnimating = false;
    this.completedCount = 0;
    
    this.init();
    this.loop();
  }

  init() {
    // çº¢åŒ…ä½ç½®ï¼ˆé¡¶éƒ¨ï¼Œå‡åŒ€åˆ†å¸ƒï¼‰
    const packetY = 150;
    const spacing = 720 / 4;
    COLORS.forEach((color, idx) => {
      this.packets.push(new RedPacket(spacing * (idx + 1), packetY, color));
    });
    
    // ç“¶å­ä½ç½®ï¼ˆåº•éƒ¨å±…ä¸­ï¼Œæ¨ªå‘æ’åˆ—ï¼‰
    const bottleY = 850;
    const bottleW = 100;
    const gap = 40;
    const totalW = 4 * bottleW + 3 * gap;
    const startX = (720 - totalW) / 2;
    
    // åˆå§‹å¸ƒå±€ï¼ˆæœ‰è§£çš„å…³å¡ï¼‰
    const layouts = [
      [COLORS[0], COLORS[1], COLORS[2], COLORS[0]], // çº¢è“ç»¿çº¢
      [COLORS[1], COLORS[2], COLORS[0], COLORS[1]], // è“ç»¿çº¢è“
      [COLORS[2], COLORS[0], COLORS[1], COLORS[2]], // ç»¿çº¢è“ç»¿
      [] // ç©ºç“¶
    ];
    
    layouts.forEach((colors, idx) => {
      this.bottles.push(new Bottle(
        startX + idx * (bottleW + gap),
        bottleY,
        idx,
        colors
      ));
    });
    
    // ç‚¹å‡»äº‹ä»¶ï¼ˆåæ ‡éœ€ç›¸å¯¹äºcanvasï¼‰
    canvas.addEventListener('click', (e) => this.handleInput(e.offsetX, e.offsetY));
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const scaleX = 720 / rect.width;
      const scaleY = 1280 / rect.height;
      this.handleInput(
        (e.touches[0].clientX - rect.left) * scaleX,
        (e.touches[0].clientY - rect.top) * scaleY
      );
    });
  }

  handleInput(x, y) {
    if(this.isAnimating || this.pouring) return;
    
    // æ£€æŸ¥ç‚¹å‡»ç“¶å­
    const idx = this.bottles.findIndex(b => b.contains(x, y));
    if(idx === -1) return;
    
    const bottle = this.bottles[idx];
    
    if(this.selectedIndex === null) {
      if(bottle.colors.length === 0) {
        this.showHint('ç©ºç“¶å­ä¸èƒ½é€‰æ‹©', true);
        return;
      }
      bottle.selected = true;
      this.selectedIndex = idx;
      this.showHint('å†ç‚¹å‡»ç›®æ ‡ç“¶å­å€’æ°´');
    } else if(this.selectedIndex === idx) {
      bottle.selected = false;
      this.selectedIndex = null;
      this.showHint('ç‚¹å‡»ç“¶å­é€‰æ‹©ï¼Œå€’æ°´åˆ°åŒè‰²');
    } else {
      this.attemptPour(this.selectedIndex, idx);
    }
  }

  attemptPour(fromIdx, toIdx) {
    const from = this.bottles[fromIdx];
    const to = this.bottles[toIdx];
    
    const fromColor = from.colors[from.colors.length - 1];
    const toTop = to.colors[to.colors.length - 1];
    
    if(to.colors.length >= 4) {
      this.showHint('ç›®æ ‡ç“¶å­å·²æ»¡', true);
      return;
    }
    if(toTop && toTop.name !== fromColor.name) {
      this.showHint('åªèƒ½å€’å…¥ç›¸åŒé¢œè‰²', true);
      return;
    }
    
    // å¼€å§‹å€’æ°´åŠ¨ç”»
    this.isAnimating = true;
    from.selected = false;
    this.selectedIndex = null;
    
    this.pouring = new PourAnimation(from, to, fromColor);
    
    // å»¶è¿Ÿæ‰§è¡Œæ•°æ®æ›´æ–°
    setTimeout(() => {
      to.colors.push(fromColor);
      from.colors.pop();
      
      // æ£€æŸ¥æ»¡ç“¶
      if(to.colors.length === 4 && to.colors.every(c => c.name === fromColor.name)) {
        to.corked = true;
        setTimeout(() => this.collectBottle(to, fromColor), 600);
      } else {
        this.isAnimating = false;
        this.pouring = null;
        this.showHint('ç‚¹å‡»ç“¶å­é€‰æ‹©ï¼Œå€’æ°´åˆ°åŒè‰²');
      }
    }, 800);
  }

  collectBottle(bottle, color) {
    const packet = this.packets.find(p => p.color.name === color.name && !p.collected);
    if(packet) {
      packet.collect();
      this.completedCount++;
      
      // ç“¶å­é£å…¥çº¢åŒ…åŠ¨ç”»
      const targetX = packet.x;
      const targetY = packet.y;
      
      bottle.isFlying = true;
      bottle.targetX = targetX;
      bottle.targetY = targetY;
      bottle.flyProgress = 0;
      
      setTimeout(() => {
        this.isAnimating = false;
        this.pouring = null;
        if(this.completedCount >= 3) this.showWin();
        else this.showHint('ç‚¹å‡»ç“¶å­é€‰æ‹©ï¼Œå€’æ°´åˆ°åŒè‰²');
      }, 1000);
    }
  }

  showWin() {
    this.showHint('ğŸ‰ æ­å–œé€šå…³ï¼æ‰€æœ‰çº¢åŒ…å·²é¢†å–', false);
    document.getElementById('cta').classList.add('show');
    
    // æ’’èŠ±ç‰¹æ•ˆ
    this.createConfetti();
  }

  createConfetti() {
    this.confetti = [];
    for(let i=0; i<100; i++) {
      this.confetti.push({
        x: 360, y: 640,
        vx: (Math.random()-0.5)*20,
        vy: (Math.random()-0.5)*20 - 10,
        color: COLORS[Math.floor(Math.random()*3)].main,
        size: 5 + Math.random()*10,
        rotation: Math.random()*360
      });
    }
  }

  showHint(text, isError = false) {
    const hint = document.getElementById('hint');
    hint.textContent = text;
    hint.className = isError ? 'hint-box error' : 'hint-box';
  }

  loop() {
    ctx.clearRect(0, 0, width, height);
    
    // ç»˜åˆ¶èƒŒæ™¯è£…é¥°ï¼ˆæ˜Ÿæ˜Ÿç‚¹ç‚¹ï¼‰
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    for(let i=0; i<20; i++) {
      const x = (i * 137) % 720;
      const y = (i * 73) % 600;
      ctx.beginPath();
      ctx.arc(x, y, 1 + (i%3), 0, Math.PI*2);
      ctx.fill();
    }
    
    // ç»˜åˆ¶çº¢åŒ…
    this.packets.forEach(p => p.draw(ctx));
    
    // ç»˜åˆ¶å€’æµåŠ¨ç”»
    if(this.pouring) {
      this.pouring.update();
      this.pouring.draw(ctx);
    }
    
    // ç»˜åˆ¶ç“¶å­
    this.bottles.forEach(bottle => {
      if(bottle.isFlying) {
        // é£è¡ŒåŠ¨ç”»
        bottle.flyProgress += 0.05;
        const t = bottle.flyProgress;
        bottle.x += (bottle.targetX - bottle.x) * 0.1;
        bottle.y += (bottle.targetY - bottle.y) * 0.1;
        bottle.scale = 1 - t * 0.5;
        bottle.rotation = t * 720;
        
        ctx.save();
        ctx.translate(bottle.x + bottle.width/2, bottle.y + bottle.height/2);
        ctx.scale(bottle.scale, bottle.scale);
        ctx.rotate(bottle.rotation * Math.PI/180);
        ctx.translate(-bottle.width/2, -bottle.height/2);
        bottle.draw(ctx);
        ctx.restore();
        
        if(t >= 1) bottle.visible = false;
      } else if(bottle.visible !== false) {
        bottle.draw(ctx);
      }
    });
    
    // ç»˜åˆ¶åº†ç¥å½©çº¸
    if(this.confetti) {
      this.confetti.forEach(c => {
        c.x += c.vx;
        c.y += c.vy;
        c.vy += 0.5;
        c.rotation += 5;
        
        ctx.save();
        ctx.translate(c.x, c.y);
        ctx.rotate(c.rotation * Math.PI/180);
        ctx.fillStyle = c.color;
        ctx.fillRect(-c.size/2, -c.size/2, c.size, c.size);
        ctx.restore();
      });
    }
    
    requestAnimationFrame(() => this.loop());
  }
}

// å¯åŠ¨
const game = new Game();

// CTAè·³è½¬
function download() {
  alert('è·³è½¬åˆ°åº”ç”¨å•†åº—');
  // window.location.href = 'ä½ çš„ä¸‹è½½é“¾æ¥';
}
</script>
</body>
</html>
